# プロトタイプの仕様
`documents`配下の資料はプロダクションレベルの話であり、実際に作成するアプリケーションはプロトタイプレベルになるため、以下にその違いを示す。また、以下の資料では次の用語を仕様する。
- プロダクションレベル
  - 意味: `documents`配下・資料中の仕様
- プロトタイプ
  - 意味: 実際に作成するアプリの仕様

## ZKP回路ファイルの配布方法
|対象|プロダクションレベル|プロトタイプ|
|:-:|:-:|:-:|
|検証鍵（以下VK）|特定のURLにアクセスしダウンロード|Polygon zkEVM上に直接保存（NFTメタデータに埋め込み）|
|証明回路ファイル|IPFSなどで配布|GitHub Releases経由で配布|

### 詳細
- Executive ConsoleがYearlySetをデプロイする際に、VKのJSONデータ自体を文字列またはバイト配列として、YearlyDeploymentManagerスマートコントラクトのストレージに直接保存する。
- この際、VKのハッシュ値（vkHash）も別途コントラクトに保存し、UI側で取得したVKとハッシュ値が一致するか検証する。
- 検証者システム (Verifier UI) は、ブロックチェーン（Polygon zkEVM）から直接、目的の年度のYearNFTコントラクトに紐づくVKデータを取得する。

## 管理者システム（Registrar Console）の機能範囲縮小
- 「YearlySet」の概念は「年度別独立性」という重要な原則を表しますが、プロトタイプでは単一の年度（例: 2025年度）のYearlySetのみをデプロイ・運用することで十分。よって、手動でファイルに用意したパスキーの公開鍵をjson形式で保存する。これにより、複数年度の切り替えや管理UIの複雑さを回避する。
- Ptauファイルの管理は複雑になりがちである。プロトタイプでは、事前に生成されたPtauファイルをExecutive Consoleの実行環境に配置し、コンパイル時にそれを参照するだけで済むようにする。

## 非機能要件の優先度調整
- 「教授の視点から動作するプロトタイプ」という目的に鑑み、厳密なパフォーマンス目標（例: ZKP生成5秒以内、検証100ms以内など）や、網羅的なエラーハンドリング、監査ログ、多言語対応、高度なアクセシビリティといったプロダクションレベルの非機能要件は、プロトタイプでは優先度を下げ、主要なデモシナリオがスムーズに動作することに焦点を当てる。
- Verifier UIの「完全オフライン検証（Service Worker）」は、プロジェクトの重要な特徴の一つだが、実装には手間がかかる。よって、UIにアクセスできた時点でオンラインとみなし、完全オフラインは要件に含めない。

## テスト範囲の絞り込み
- 全システムの詳細なユニットテストやE2Eテストはプロダクション向けである。プロトタイプでは**教授が実際に確認する主要なユースケース**（例: Scholar Proverでの証明生成、Verifier UIでの検証、Executive ConsoleでのYearlySetデプロイとLedger署名）に絞って、ハッピーパス（正常系）の動作を確認する手動テストで十分。

## Polygon zkEVMテストネットの利用
経費節約のため、zkEVMはメインネットではなくAmoyテストネットを利用する。プロトタイプはAmoyテストネット上にスマートコントラクトをデプロイし、動作確認を行う。

## ツールの活用方法
- GitHub PagesでVerifier UIを配布。
- Tauriアプリケーションの配布はGitHub Releasesを通じた署名付きバイナリとして行う。
