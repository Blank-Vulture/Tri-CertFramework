# è²¬ä»»è€…ã‚·ã‚¹ãƒ†ãƒ  è©³ç´°è¨­è¨ˆæ›¸ï¼ˆTauri v2ãƒ»ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ãƒ¬ã‚¹ç‰ˆï¼‰

## ãƒãƒ¼ã‚¸ãƒ§ãƒ³æƒ…å ±
- **Version**: 2.1
- **Last Updated**: 2025-06-21
- **Target**: ãƒ—ãƒ­ãƒˆã‚¿ã‚¤ãƒ— 2025å¹´10æœˆ

## 1. ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£æ¦‚è¦

### 1.1 å®Œå…¨ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ãƒ¬ã‚¹è¨­è¨ˆ
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ è²¬ä»»è€…ã‚·ã‚¹ãƒ†ãƒ  (Tauri v2 App)        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â€¢ å¹´åº¦åˆ¥ã‚»ãƒƒãƒˆç®¡ç†                    â”‚
â”‚ â€¢ ãƒ­ãƒ¼ã‚«ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸            â”‚
â”‚ â€¢ Web3ãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼ï¼ˆèª­ã¿å–ã‚Šå°‚ç”¨ï¼‰      â”‚
â”‚ â€¢ è¨­å®šJSONãƒ•ã‚¡ã‚¤ãƒ«                    â”‚
â”‚ â€¢ å›è·¯ãƒ»ã‚­ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«ç®¡ç†               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“ èª­ã¿å–ã‚Šå°‚ç”¨æ¥ç¶š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Blockchain (Polygon zkEVM)          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â€¢ YearlyDeploymentManager.sol       â”‚
â”‚ â€¢ DocumentNFT2025.sol               â”‚
â”‚ â€¢ DocumentNFT2026.sol               â”‚
â”‚ â€¢ ...                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“ ãƒ­ãƒ¼ã‚«ãƒ«ä¿å­˜
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Local File System                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â€¢ circuits/Document2025.circom      â”‚
â”‚ â€¢ keys/Document2025.zkey            â”‚
â”‚ â€¢ keys/Document2025_vk.json         â”‚
â”‚ â€¢ exports/circuit_hashes.json       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ç‰¹å¾´:
âœ… ã‚µãƒ¼ãƒãƒ¼ä¸è¦
âœ… ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ä¸è¦
âœ… APIä¸è¦
âœ… è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã®ã¿
âœ… ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—ã‚¢ãƒ—ãƒªé…å¸ƒ
âœ… Rust + WebViewã§è»½é‡ãƒ»é«˜é€Ÿ
```

---

## 2. ã‚¹ãƒãƒ¼ãƒˆã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆè¨­è¨ˆï¼ˆæ±ç”¨æ–‡æ›¸å¯¾å¿œç‰ˆï¼‰

### 2.1 YearlyDeploymentManager.solï¼ˆæ–‡æ›¸å¯¾å¿œç‰ˆï¼‰
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/access/Ownable.sol";
import "./DocumentNFT.sol";

contract YearlyDeploymentManager is Ownable {
    struct YearlySet {
        uint256 year;
        address nftContract;
        bytes32 vkHash;
        bytes32 merkleRoot;
        bytes32 circuitHash;        // å®Œå…¨ãƒ­ãƒ¼ã‚«ãƒ«åŒ–ï¼šIPFSãƒãƒƒã‚·ãƒ¥å»ƒæ­¢
        string documentType;        // æ–‡æ›¸ã‚¿ã‚¤ãƒ—ï¼ˆä¾‹ï¼šgraduation, certificate, licenseï¼‰
        uint256 deployedAt;
    }
    
    mapping(uint256 => YearlySet) public yearlySets;
    mapping(string => mapping(uint256 => address)) public documentContracts; // documentType -> year -> contract
    uint256[] public deployedYears;
    
    event YearlySetCreated(
        uint256 indexed year,
        address nftContract,
        bytes32 vkHash,
        bytes32 circuitHash,
        string documentType
    );
    
      /**
   * @dev æ–°å¹´åº¦ã‚»ãƒƒãƒˆã‚’ãƒ¯ãƒ³ã‚¯ãƒªãƒƒã‚¯ãƒ‡ãƒ—ãƒ­ã‚¤
   */
  function createYearlySet(
      uint256 year,
      bytes32 vkHash,
      bytes32 merkleRoot,
      bytes32 circuitHash,
      string calldata documentType,
      string calldata nftName,
      string calldata nftSymbol
  ) external onlyOwner returns (address) {
      require(yearlySets[year].deployedAt == 0, "Year already exists");
      
      // NFTã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã‚’ãƒ‡ãƒ—ãƒ­ã‚¤
      DocumentNFT nft = new DocumentNFT(
          year,
          vkHash,
          merkleRoot,
          documentType,
          nftName,
          nftSymbol
      );
      
      // æƒ…å ±ã‚’è¨˜éŒ²ï¼ˆå®Œå…¨ãƒ­ãƒ¼ã‚«ãƒ«åŒ–ï¼‰
      yearlySets[year] = YearlySet({
          year: year,
          nftContract: address(nft),
          vkHash: vkHash,
          merkleRoot: merkleRoot,
          circuitHash: circuitHash,
          documentType: documentType,
          deployedAt: block.timestamp
      });
      
      documentContracts[documentType][year] = address(nft);
      deployedYears.push(year);
      
      emit YearlySetCreated(year, address(nft), vkHash, circuitHash, documentType);
      return address(nft);
  }
    
    /**
     * @dev å¹´åº¦æƒ…å ±å–å¾—
     */
    function getYearlySet(uint256 year) external view returns (YearlySet memory) {
        return yearlySets[year];
    }
    
    /**
     * @dev æ–‡æ›¸ã‚¿ã‚¤ãƒ—åˆ¥ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆå–å¾—
     */
    function getDocumentContract(string calldata documentType, uint256 year) 
        external view returns (address) {
        return documentContracts[documentType][year];
    }
    
    /**
     * @dev å…¨å¹´åº¦å–å¾—
     */
    function getAllYears() external view returns (uint256[] memory) {
        return deployedYears;
    }
}
```

### 2.2 DocumentNFT.solï¼ˆæ±ç”¨æ–‡æ›¸å¯¾å¿œç‰ˆï¼‰
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract DocumentNFT is ERC721, Ownable {
    uint256 public immutable ISSUE_YEAR;
    bytes32 public immutable VK_HASH;
    string public immutable DOCUMENT_TYPE;
    bytes32 public merkleRoot;
    
    mapping(address => bool) public hasClaimed;
    uint256 private _tokenIdCounter;
    
    event DocumentNFTMinted(address indexed owner, uint256 tokenId, string documentType);
    
    constructor(
        uint256 _year,
        bytes32 _vkHash,
        bytes32 _merkleRoot,
        string memory _documentType,
        string memory _name,
        string memory _symbol
    ) ERC721(_name, _symbol) {
        ISSUE_YEAR = _year;
        VK_HASH = _vkHash;
        DOCUMENT_TYPE = _documentType;
        merkleRoot = _merkleRoot;
    }
    
    /**
     * @dev æ–‡æ›¸NFTã‚’ãƒŸãƒ³ãƒˆï¼ˆZKP + Merkle Treeæ¤œè¨¼ï¼‰
     */
    function mintDocumentNFT(
        bytes calldata zkProof,
        uint256[] calldata publicInputs,
        bytes32[] calldata merkleProof
    ) external {
        require(!hasClaimed[msg.sender], "Already claimed");
        require(publicInputs[2] / 1000000 == ISSUE_YEAR, "Wrong year");
        
        // ZKPæ¤œè¨¼ï¼ˆç°¡ç•¥åŒ– - å®Ÿéš›ã¯è©³ç´°ãªæ¤œè¨¼ï¼‰
        require(verifyZKProof(zkProof, publicInputs), "Invalid ZK proof");
        
        // Merkle Treeæ¤œè¨¼
        require(verifyMerkleProof(msg.sender, merkleProof), "Not eligible");
        
        hasClaimed[msg.sender] = true;
        uint256 tokenId = _tokenIdCounter++;
        
        _safeMint(msg.sender, tokenId);
        emit DocumentNFTMinted(msg.sender, tokenId, DOCUMENT_TYPE);
    }
    
    function verifyZKProof(bytes calldata, uint256[] calldata) internal view returns (bool) {
        // å®Ÿè£…ã¯è¨¼æ˜è€…ã‚·ã‚¹ãƒ†ãƒ ã§æ¤œè¨¼æ¸ˆã¿ã®è¨¼æ˜ã‚’ä¿¡é ¼
        return true; // ç°¡ç•¥åŒ–
    }
    
    function verifyMerkleProof(address user, bytes32[] calldata proof) internal view returns (bool) {
        bytes32 leaf = keccak256(abi.encodePacked(user));
        bytes32 computedHash = leaf;
        
        for (uint256 i = 0; i < proof.length; i++) {
            bytes32 proofElement = proof[i];
            computedHash = computedHash <= proofElement 
                ? keccak256(abi.encodePacked(computedHash, proofElement))
                : keccak256(abi.encodePacked(proofElement, computedHash));
        }
        
        return computedHash == merkleRoot;
    }

    function totalSupply() external view returns (uint256) {
        return _tokenIdCounter;
    }
}
```

---

## 3. ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—ã‚¢ãƒ—ãƒªè¨­è¨ˆï¼ˆTauri v2 + React + TypeScriptï¼‰

### 3.1 ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³æ§‹æˆ
```
executive-console-app/
â”œâ”€â”€ src-tauri/              # Tauriãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ï¼ˆRustï¼‰
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ main.rs         # Tauriãƒ¡ã‚¤ãƒ³ãƒ—ãƒ­ã‚»ã‚¹
â”‚   â”‚   â”œâ”€â”€ commands.rs     # ãƒ•ã‚¡ã‚¤ãƒ«æ“ä½œã‚³ãƒãƒ³ãƒ‰
â”‚   â”‚   â””â”€â”€ lib.rs          # ãƒ©ã‚¤ãƒ–ãƒ©ãƒª
â”‚   â”œâ”€â”€ Cargo.toml          # Rustä¾å­˜é–¢ä¿‚
â”‚   â””â”€â”€ tauri.conf.json     # Tauriè¨­å®š
â”œâ”€â”€ src/                    # Reactãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰
â”‚   â”œâ”€â”€ main.tsx            # React ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆ
â”‚   â”œâ”€â”€ App.tsx             # ãƒ¡ã‚¤ãƒ³ã‚¢ãƒ—ãƒª
â”‚   â”œâ”€â”€ components/         # Reactã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
â”‚   â”œâ”€â”€ services/           # Web3ãƒ»ãƒ­ãƒ¼ã‚«ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«æ“ä½œ
â”‚   â”œâ”€â”€ hooks/              # ã‚«ã‚¹ã‚¿ãƒ ãƒ•ãƒƒã‚¯
â”‚   â””â”€â”€ utils/              # ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
â”œâ”€â”€ package.json            # Node.jsä¾å­˜é–¢ä¿‚
â”œâ”€â”€ vite.config.ts          # Viteè¨­å®š
â”œâ”€â”€ config/
â”‚   â””â”€â”€ app-config.json     # ã‚¢ãƒ—ãƒªè¨­å®šï¼ˆDBä»£æ›¿ï¼‰
â”œâ”€â”€ circuits/               # å›è·¯ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜
â”œâ”€â”€ keys/                   # ã‚­ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜
â””â”€â”€ dist/                   # ãƒ“ãƒ«ãƒ‰æ¸ˆã¿ãƒ•ã‚¡ã‚¤ãƒ«
```

### 3.2 è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆDBä»£æ›¿ï¼‰
```json
// config/app-config.json
{
  "version": "1.0.0",
  "network": {
    "chainId": 1101,
    "rpcUrl": "https://zkevm-rpc.com",
    "deploymentManagerAddress": "0x..."
  },
  "storage": {
    "circuitsDir": "./circuits",
    "keysDir": "./keys",
    "exportsDir": "./exports"
  },
  "deployedYears": [
    {
      "year": 2025,
      "nftContract": "0x...",
      "vkHash": "0x...",
      "circuitHash": "0x...",
      "localCircuitPath": "./circuits/Document2025.circom",
      "localVKPath": "./keys/Document2025_vk.json",
      "localZkeyPath": "./keys/Document2025.zkey",
      "merkleRoot": "0x...",
      "deployedAt": 1640995200
    }
  ],
  "userSettings": {
    "privateKey": "encrypted_key_here",
    "autoSave": true,
    "theme": "dark"
  }
}
```

### 3.3 ãƒ¡ã‚¤ãƒ³ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³
```typescript
// src/App.tsx
import React, { useState, useEffect } from 'react';
import { 
  ThemeProvider, 
  CssBaseline, 
  Container, 
  AppBar, 
  Toolbar, 
  Typography,
  Tab,
  Tabs,
  Box
} from '@mui/material';
import { YearlySetManager } from './components/YearlySetManager';
import { SystemStatus } from './components/SystemStatus';
import { Settings } from './components/Settings';
import { ConfigService } from './services/ConfigService';
import { Web3Service } from './services/Web3Service';

interface AppConfig {
  network: any;
  deployedYears: any[];
  userSettings: any;
}

const App: React.FC = () => {
  const [config, setConfig] = useState<AppConfig | null>(null);
  const [activeTab, setActiveTab] = useState(0);
  const [web3Service, setWeb3Service] = useState<Web3Service | null>(null);

  useEffect(() => {
    loadConfig();
  }, []);

  const loadConfig = async () => {
    try {
      const configService = new ConfigService();
      const appConfig = await configService.loadConfig();
      setConfig(appConfig);
      
      // Web3ã‚µãƒ¼ãƒ“ã‚¹åˆæœŸåŒ–
      const web3 = new Web3Service(appConfig.network);
      setWeb3Service(web3);
    } catch (error) {
      console.error('Failed to load config:', error);
    }
  };

  const saveConfig = async (newConfig: AppConfig) => {
    const configService = new ConfigService();
    await configService.saveConfig(newConfig);
    setConfig(newConfig);
  };

  if (!config || !web3Service) {
    return <div>Loading...</div>;
  }

  return (
    <ThemeProvider theme={createTheme({ palette: { mode: 'dark' } })}>
      <CssBaseline />
      <Container maxWidth="lg">
        <AppBar position="static" elevation={0}>
          <Toolbar>
            <Typography variant="h6" component="div" sx={{ flexGrow: 1 }}>
              è²¬ä»»è€…ã‚·ã‚¹ãƒ†ãƒ  - å¹´æ¬¡ã‚»ãƒƒãƒˆç®¡ç†
            </Typography>
          </Toolbar>
        </AppBar>

        <Box sx={{ borderBottom: 1, borderColor: 'divider', mt: 2 }}>
          <Tabs value={activeTab} onChange={(_, value) => setActiveTab(value)}>
            <Tab label="å¹´æ¬¡ã‚»ãƒƒãƒˆç®¡ç†" />
            <Tab label="ã‚·ã‚¹ãƒ†ãƒ çŠ¶æ…‹" />
            <Tab label="è¨­å®š" />
          </Tabs>
        </Box>

        <Box sx={{ mt: 3 }}>
          {activeTab === 0 && (
            <YearlySetManager 
              config={config}
              web3Service={web3Service}
              onConfigUpdate={saveConfig}
            />
          )}
          {activeTab === 1 && (
            <SystemStatus 
              config={config}
              web3Service={web3Service}
            />
          )}
          {activeTab === 2 && (
            <Settings 
              config={config}
              onConfigUpdate={saveConfig}
            />
          )}
        </Box>
      </Container>
    </ThemeProvider>
  );
};

export default App;
```

### 3.4 å¹´æ¬¡ã‚»ãƒƒãƒˆç®¡ç†ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
```typescript
// src/components/YearlySetManager.tsx
import React, { useState } from 'react';
import { 
  Card, 
  CardContent, 
  Typography, 
  Button, 
  Grid,
  Box,
  Chip,
  List,
  ListItem,
  ListItemText,
  IconButton
} from '@mui/material';
import { Add, Launch, Folder } from '@mui/icons-material';
import { CreateYearlySetDialog } from './CreateYearlySetDialog';
import { Web3Service } from '../services/Web3Service';

interface YearlySetManagerProps {
  config: any;
  web3Service: Web3Service;
  onConfigUpdate: (config: any) => void;
}

export const YearlySetManager: React.FC<YearlySetManagerProps> = ({
  config,
  web3Service,
  onConfigUpdate
}) => {
  const [createDialogOpen, setCreateDialogOpen] = useState(false);
  const [deployedYears] = useState(config.deployedYears || []);

  const handleCreateNewSet = async (yearData: {
    year: number;
    circuitFile: File;
    vkFile: File;
    studentListFile: File;
    nftName: string;
    nftSymbol: string;
  }) => {
    try {
      // 1. ãƒ­ãƒ¼ã‚«ãƒ«ã«ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜
      await saveFilesLocally(yearData);
      
      // 2. å›è·¯ãƒ•ã‚¡ã‚¤ãƒ«ãƒãƒƒã‚·ãƒ¥è¨ˆç®—ï¼ˆIPFSä¸è¦ï¼‰
      const circuitHash = await calculateFileHash(yearData.circuitFile);
      
      // 3. VKãƒãƒƒã‚·ãƒ¥è¨ˆç®—
      const vkHash = await calculateVKHash(yearData.vkFile);
      
      // 4. Merkle Treeæ§‹ç¯‰
      const merkleRoot = await buildMerkleTree(yearData.studentListFile);
      
      // 5. ãƒ–ãƒ­ãƒƒã‚¯ãƒã‚§ãƒ¼ãƒ³ãƒ‡ãƒ—ãƒ­ã‚¤ï¼ˆãƒ­ãƒ¼ã‚«ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«å‚ç…§ï¼‰
      const nftAddress = await web3Service.createYearlySet(
        yearData.year,
        vkHash,
        merkleRoot,
        circuitHash,
        yearData.nftName,
        yearData.nftSymbol
      );
      
      // 6. è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«æ›´æ–°ï¼ˆå®Œå…¨ãƒ­ãƒ¼ã‚«ãƒ«ï¼‰
      const newYearData = {
        year: yearData.year,
        nftContract: nftAddress,
        vkHash,
        circuitHash,
        localCircuitPath: `./circuits/Document${yearData.year}.circom`,
        localVKPath: `./keys/Document${yearData.year}_vk.json`,
        localZkeyPath: `./keys/Document${yearData.year}.zkey`,
        merkleRoot,
        deployedAt: Date.now()
      };
      
      const updatedConfig = {
        ...config,
        deployedYears: [...config.deployedYears, newYearData]
      };
      
      onConfigUpdate(updatedConfig);
      setCreateDialogOpen(false);
      
    } catch (error) {
      console.error('Failed to create yearly set:', error);
    }
  };

  const openCircuitFolder = (year: number) => {
    // Tauriã®ã‚·ã‚§ãƒ«æ©Ÿèƒ½ã§ãƒ•ã‚©ãƒ«ãƒ€ã‚’é–‹ã
    window.__TAURI__.shell.open(`./circuits/`);
  };

  return (
    <Box>
      <Box display="flex" justifyContent="space-between" alignItems="center" mb={3}>
        <Typography variant="h5">å¹´æ¬¡ã‚»ãƒƒãƒˆç®¡ç†</Typography>
        <Button 
          variant="contained" 
          startIcon={<Add />}
          onClick={() => setCreateDialogOpen(true)}
        >
          æ–°å¹´åº¦ã‚»ãƒƒãƒˆä½œæˆ
        </Button>
      </Box>

      <Grid container spacing={3}>
        {deployedYears.map((yearSet: any) => (
          <Grid item xs={12} md={6} key={yearSet.year}>
            <Card>
              <CardContent>
                <Box display="flex" justifyContent="space-between" alignItems="center" mb={2}>
                  <Typography variant="h6">{yearSet.year}å¹´åº¦</Typography>
                  <Chip label="ãƒ‡ãƒ—ãƒ­ã‚¤æ¸ˆã¿" color="success" size="small" />
                </Box>
                
                <List dense>
                  <ListItem>
                    <ListItemText
                      primary="NFTã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆ"
                      secondary={
                        <code style={{ fontSize: '0.8em' }}>
                          {yearSet.nftContract}
                        </code>
                      }
                    />
                    <IconButton 
                      size="small"
                      onClick={() => window.open(`https://zkevm.polygonscan.com/address/${yearSet.nftContract}`)}
                    >
                      <Launch />
                    </IconButton>
                  </ListItem>
                  
                                      <ListItem>
                    <ListItemText
                      primary="å›è·¯ãƒ•ã‚¡ã‚¤ãƒ«"
                      secondary={`Document${yearSet.year}.circom`}
                    />
                    <IconButton 
                      size="small"
                      onClick={() => openCircuitFolder(yearSet.year)}
                    >
                      <Folder />
                    </IconButton>
                  </ListItem>
                  
                  <ListItem>
                    <ListItemText
                      primary="å›è·¯ãƒãƒƒã‚·ãƒ¥"
                      secondary={
                        <code style={{ fontSize: '0.8em' }}>
                          {yearSet.circuitHash}
                        </code>
                      }
                    />
                  </ListItem>
                </List>
              </CardContent>
            </Card>
          </Grid>
        ))}
      </Grid>

      <CreateYearlySetDialog
        open={createDialogOpen}
        onClose={() => setCreateDialogOpen(false)}
        onSubmit={handleCreateNewSet}
      />
    </Box>
  );
};
```

### 3.5 ã‚µãƒ¼ãƒ“ã‚¹ã‚¯ãƒ©ã‚¹ï¼ˆã‚·ãƒ³ãƒ—ãƒ«ç‰ˆï¼‰
```typescript
// src/services/ConfigService.ts
import fs from 'fs/promises';
import path from 'path';

export class ConfigService {
  private configPath = path.join(process.cwd(), 'config', 'app-config.json');

  async loadConfig(): Promise<any> {
    try {
      const data = await fs.readFile(this.configPath, 'utf-8');
      return JSON.parse(data);
    } catch (error) {
      // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®šã‚’è¿”ã™
      return this.getDefaultConfig();
    }
  }

  async saveConfig(config: any): Promise<void> {
    await fs.writeFile(this.configPath, JSON.stringify(config, null, 2));
  }

  private getDefaultConfig() {
    return {
      version: "1.0.0",
      network: {
        chainId: 1101,
        rpcUrl: "https://zkevm-rpc.com"
      },
      deployedYears: [],
      userSettings: {
        theme: "dark",
        autoSave: true
      }
    };
  }
}

// src/services/LedgerWeb3Service.ts
import { ethers } from 'ethers';
import TransportWebUSB from '@ledgerhq/hw-transport-webusb';
import AppEth from '@ledgerhq/hw-app-eth';

export class LedgerWeb3Service {
  private provider: ethers.Provider;
  private ledgerApp: AppEth | null = null;
  private ledgerAddress: string = '';
  private deploymentManager: ethers.Contract;
  private usedNonces: Set<string> = new Set();

  constructor(networkConfig: any) {
    this.provider = new ethers.JsonRpcProvider(networkConfig.rpcUrl);
    this.deploymentManager = new ethers.Contract(
      networkConfig.deploymentManagerAddress,
      YearlyDeploymentManagerABI,
      this.provider // Providerã®ã¿ã€ç½²åã¯Ledgerã§
    );
  }

  async connectLedger(): Promise<string> {
    try {
      const transport = await TransportWebUSB.create();
      this.ledgerApp = new AppEth(transport);
      
      // ã‚¢ãƒ‰ãƒ¬ã‚¹å–å¾—ï¼ˆpath: m/44'/60'/0'/0/0ï¼‰
      const result = await this.ledgerApp.getAddress("44'/60'/0'/0/0");
      this.ledgerAddress = result.address;
      
      return this.ledgerAddress;
    } catch (error) {
      throw new Error(`Ledgeræ¥ç¶šå¤±æ•—: ${error.message}`);
    }
  }

  async signEIP191Message(message: string): Promise<string> {
    if (!this.ledgerApp) {
      throw new Error('Ledgeræœªæ¥ç¶š');
    }

    try {
      // EIP-191 Personal Sign
      const result = await this.ledgerApp.signPersonalMessage(
        "44'/60'/0'/0/0",
        Buffer.from(message, 'utf8').toString('hex')
      );
      
      // ç½²åã‚’etherså½¢å¼ã«å¤‰æ›
      const signature = `0x${result.r}${result.s}${result.v.toString(16)}`;
      return signature;
    } catch (error) {
      throw new Error(`Ledgerç½²åå¤±æ•—: ${error.message}`);
    }
  }

  async createYearlySetWithLedger(
    year: number,
    vkHash: string,
    merkleRoot: string,
    circuitHash: string,
    nftName: string,
    nftSymbol: string
  ): Promise<string> {
    // 1. EIP-191ç½²åã«ã‚ˆã‚‹èªè¨¼
    const authMessage = this.generateAuthMessage('deploy_yearly_set', {
      year,
      vkHash,
      merkleRoot,
      circuitHash,
      nftName,
      nftSymbol
    });
    
    console.log('ğŸ” Ledger Nano Xã§ã®ç½²åãŒå¿…è¦ã§ã™...');
    const signature = await this.signEIP191Message(authMessage);
    
    // 2. ç½²åæ¤œè¨¼
    const recovered = ethers.verifyMessage(authMessage, signature);
    if (recovered.toLowerCase() !== this.ledgerAddress.toLowerCase()) {
      throw new Error('ç½²åæ¤œè¨¼å¤±æ•—');
    }
    
    // 3. ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ä½œæˆ
    const tx = await this.deploymentManager.createYearlySet.populateTransaction(
      year,
      vkHash,
      merkleRoot,
      circuitHash,
      nftName,
      nftSymbol
    );
    
    // 4. Ledgerã§ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ç½²å
    console.log('ğŸ“± Ledger Nano Xã§ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’ç¢ºèªã—ã¦ãã ã•ã„...');
    const signedTx = await this.signTransactionWithLedger(tx);
    
    // 5. ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³é€ä¿¡
    const receipt = await this.provider.broadcastTransaction(signedTx);
    await receipt.wait();
    
    const event = receipt.logs?.find((log: any) => 
      log.topics[0] === ethers.id('YearlySetCreated(uint256,address,bytes32,bytes32)')
    );
    
    return ethers.AbiCoder.defaultAbiCoder().decode(['address'], event?.data || '')[0];
  }

  private generateAuthMessage(operation: string, params: any): string {
    const timestamp = Date.now();
    const nonce = crypto.randomUUID();
    
    return `
ğŸ” zk-CertFramework Executive Console v1.0.0

âš ï¸  SECURITY WARNING âš ï¸
Only sign if you initiated this action!

Operation: ${operation}
Year: ${params.year}
Circuit Hash: ${params.circuitHash}
VK Hash: ${params.vkHash}
Merkle Root: ${params.merkleRoot}
NFT Name: ${params.nftName}
NFT Symbol: ${params.nftSymbol}
Timestamp: ${new Date(timestamp).toISOString()}
Nonce: ${nonce}
Domain: zk-cert-framework.local

ğŸ“± Verify on Ledger screen:
- Operation matches your intention
- Year is correct: ${params.year}
- All parameters are expected

âŒ NEVER sign if:
- You didn't initiate this action
- Parameters don't match
- Domain is not zk-cert-framework.local
`;
  }

  private async signTransactionWithLedger(tx: any): Promise<string> {
    if (!this.ledgerApp) {
      throw new Error('Ledgeræœªæ¥ç¶š');
    }

    // ã‚¬ã‚¹è¨­å®š
    tx.gasLimit = await this.provider.estimateGas(tx);
    tx.gasPrice = await this.provider.getGasPrice();
    tx.nonce = await this.provider.getTransactionCount(this.ledgerAddress);
    tx.chainId = (await this.provider.getNetwork()).chainId;

    // Ledgerã§ç½²å
    const serializedTx = ethers.Transaction.from(tx).unsignedSerialized;
    const result = await this.ledgerApp.signTransaction(
      "44'/60'/0'/0/0",
      serializedTx.slice(2) // 0xé™¤å»
    );

    // ç½²åã‚’ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã«é©ç”¨
    const signature = {
      r: '0x' + result.r,
      s: '0x' + result.s,
      v: parseInt(result.v, 16)
    };

    const signedTx = ethers.Transaction.from({
      ...tx,
      signature
    });

    return signedTx.serialized;
  }

  async verifyConnection(): Promise<boolean> {
    try {
      return this.ledgerApp !== null && this.ledgerAddress !== '';
    } catch {
      return false;
    }
  }
}
```

---

## 4. é…å¸ƒãƒ»ãƒ‡ãƒ—ãƒ­ã‚¤

### 4.1 Tauriã‚¢ãƒ—ãƒªãƒ“ãƒ«ãƒ‰
```bash
# ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸åŒ–
npm run build
npm run tauri build

# å‡ºåŠ›ãƒ•ã‚¡ã‚¤ãƒ«
dist/
â”œâ”€â”€ ExecutiveConsole-1.0.0.exe     # Windows
â”œâ”€â”€ ExecutiveConsole-1.0.0.dmg     # macOS  
â””â”€â”€ ExecutiveConsole-1.0.0.AppImage # Linux
```

### 4.2 åˆ©ç‚¹
```
âœ… è¶…ã‚·ãƒ³ãƒ—ãƒ«
- ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ä¸è¦
- ã‚µãƒ¼ãƒãƒ¼ä¸è¦
- è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã®ã¿

âœ… ç ”ç©¶é…å¸ƒã«æœ€é©
- å˜ä¸€å®Ÿè¡Œãƒ•ã‚¡ã‚¤ãƒ«
- ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ç°¡å˜
- ãƒ‡ãƒ¢ãŒç°¡å˜

âœ… ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£
- ãƒ­ãƒ¼ã‚«ãƒ«å®Ÿè¡Œ
- ç§˜å¯†éµãƒ­ãƒ¼ã‚«ãƒ«ä¿å­˜
- å¤–éƒ¨ä¾å­˜ãªã—

âœ… é–‹ç™ºåŠ¹ç‡
- å¹´åº¦åˆ¥å®Œå…¨ç‹¬ç«‹
- ã‚­ãƒ¼ãƒ­ãƒ¼ãƒ†ä¸è¦
- è¤‡é›‘ãªçŠ¶æ…‹ç®¡ç†ãªã—