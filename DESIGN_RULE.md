# zk-CertFramework AI協働開発デザインルール

**Version 3.0 | 最終更新: 2025-01-27**

---

## 🎯 AI協働開発の目的と原則

### 1. 目的
**Trust Minimized・完全バックエンドレス・ゼロ知識書類真正性証明システム**の効率的な開発を、AIと人間の協働により実現する。

### 2. AI協働の核心原則
- **明確性優先**: 曖昧さを排除し、具体的で実行可能な指示を提供
- **構造化思考**: 段階的な情報提示により、AIの理解と実行精度を最大化
- **検証可能性**: 全ての出力が検証・テスト可能な形で提供される
- **反復改善**: 継続的なフィードバックループによる品質向上

---

## 📋 システム理解のためのコンテキスト

### 3. プロジェクト概要
```
システム名: zk-CertFramework
目的: 書類真正性のゼロ知識証明システム（卒業証書を例として実装）
特徴: Trust Minimized（信頼最小化）、完全バックエンドレス
技術: Circom回路 + SnarkJS + WebAuthn + Polygon zkEVM
```

### 4. 4システム・アーキテクチャ
1. **Scholar Prover PWA** - 書類所有者向けZKP生成インターフェース
2. **Executive Console Tauri** - Ledger保護回路デプロイ（責任者向け）
3. **Registrar Console Tauri** - ローカル書類データ管理（管理者向け）
4. **Verifier UI SSG** - ドラッグ&ドロップ書類検証（検証者向け）

### 5. 技術制約
- **バックエンドサーバー禁止** - API、データベース、クラウド依存性なし
- **ハードウェアセキュリティ必須** - Ledger Nano X による管理者操作
- **年度別独立性** - 各卒業年度が完全に独立した回路とNFTで動作
- **オフライン検証対応** - 100%エアギャップ証明書検証

---

## 🤖 AIとの効果的なコミュニケーション戦略

### 6. プロンプト構造化の原則

#### 6.1 コンテキスト設定テンプレート
```
### コンテキスト
- システム: [対象システム名]
- 目的: [具体的な達成目標]
- 制約: [技術的・ビジネス制約]
- 現在の状況: [既存の実装状況]

### 期待する出力
- 形式: [コード/ドキュメント/説明等]
- 詳細レベル: [概要/詳細/実装レベル]
- 検証方法: [テスト方法/確認手順]
```

#### 6.2 段階的タスク分解
```
大きなタスクは必ず以下の手順で分解:
1. 要件定義 → 2. アーキテクチャ設計 → 3. 詳細設計 → 4. 実装 → 5. テスト
```

### 7. 技術仕様のための明確な指示

#### 7.1 コード生成時の必須項目
```typescript
// AIに指示する際の必須要素:
- 対象ファイル名とパス
- 依存関係とインポート
- TypeScript型定義
- エラーハンドリング
- テストケース
- ドキュメントコメント
```

#### 7.2 アーキテクチャ決定時の構造化指示
```
### アーキテクチャ決定要求テンプレート
- 問題: [解決すべき技術的課題]
- 選択肢: [検討する技術的選択肢]
- 評価基準: [Trust Minimized原則への適合性など]
- 推奨決定: [根拠とトレードオフを含む]
```

---

## 🔧 開発フローとAI活用ガイドライン

### 8. 開発フェーズ別AI活用戦略

#### 8.1 要件分析フェーズ
```
AI活用目的: 要件の構造化と矛盾チェック
推奨プロンプト形式:
- "以下の要件を分析し、矛盾や曖昧さを特定してください"
- "Trust Minimized原則に違反する要件がないか確認してください"
- "実装可能性の観点から要件をレビューしてください"
```

#### 8.2 設計フェーズ
```
AI活用目的: アーキテクチャの最適化と設計パターンの提案
推奨プロンプト形式:
- "以下の制約下で最適なアーキテクチャを提案してください"
- "セキュリティ要件を満たす設計パターンを示してください"
- "パフォーマンス要件を考慮した実装方法を提案してください"
```

#### 8.3 実装フェーズ
```
AI活用目的: 高品質なコードの生成とレビュー
必須指示事項:
- Clean Code原則の適用
- SOLID原則の遵守
- セキュリティベストプラクティスの実装
- 包括的なエラーハンドリング
- テスタビリティの確保
```

### 9. 品質保証のためのAI活用

#### 9.1 コードレビュー指示テンプレート
```
### コードレビュー要求
対象: [ファイル名/機能名]
観点: 
- セキュリティ脆弱性の有無
- パフォーマンスボトルネックの特定
- 可読性・保守性の評価
- テストカバレッジの確認
- Trust Minimized原則への適合性

出力形式: 
- 問題点の一覧（優先度付き）
- 改善提案（具体的な修正案）
- ベストプラクティスとの比較
```

#### 9.2 セキュリティ監査指示
```
### セキュリティ監査要求
スコープ: [監査対象の範囲]
基準: OWASP SCP-QRG + Trust Minimized原則
確認項目:
- 入力検証の適切性
- 秘密情報の取り扱い
- 暗号化実装の正確性
- サイドチャネル攻撃への対策
- ハードウェアセキュリティの活用

出力形式: セキュリティレポート（リスクレベル付き）
```

---

## 📚 技術参照情報とベストプラクティス

### 10. プロジェクト固有の技術ガイドライン

#### 10.1 Circom回路開発
```circom
// AIが生成すべき回路の特徴
- Poseidon256ハッシュの使用
- 効率的な制約数（目標: 65,000制約以下）
- Merkle Tree検証の最適化
- ECDSA署名検証の実装
- 適切なコメントとドキュメント
```

#### 10.2 TypeScript/React実装基準
```typescript
// AI生成コードの必須要件
- strict TypeScriptモード
- 適切な型定義とインターフェース
- React 18のベストプラクティス
- エラー境界の実装
- パフォーマンス最適化（useMemo, useCallback）
- アクセシビリティ対応（ARIA属性）
```

#### 10.3 セキュリティ実装要件
```typescript
// セキュリティ関連の必須実装事項
- 入力検証（Zod/Yupによるスキーマ検証）
- CSP (Content Security Policy) 対応
- XSS/CSRF対策
- ハードウェアセキュリティの活用
- 秘密情報の適切な管理
```

### 11. 外部リソースとの整合性

#### 11.1 デザインシステム準拠
```
参照先デザインシステム:
- Apple Human Interface Guidelines
- Material Design 3
- Microsoft Fluent 2
- AWS Cloudscape Design

適用原則:
- 一貫性のあるUI/UX
- アクセシビリティ準拠
- レスポンシブデザイン
- プラットフォーム固有の最適化
```

#### 11.2 技術標準準拠
```
準拠すべき標準:
- WebAuthn Level 2
- EIP-191 (Ethereum署名標準)
- PDF/A-3 (ISO 19005-3)
- Circom 2.1.4仕様
- SnarkJS 0.7.x API
```

---

## 🔄 継続的改善とフィードバック

### 12. AI出力の評価基準

#### 12.1 技術的品質基準
```
コード品質指標:
- 実行可能性: 100% (即座に実行可能)
- テストカバレッジ: 80%以上
- パフォーマンス: 指定要件内
- セキュリティ: 脆弱性ゼロ
- 保守性: Clean Code原則準拠
```

#### 12.2 ドキュメント品質基準
```
ドキュメント指標:
- 完全性: 全必要事項の網羅
- 正確性: 技術的事実の正確性
- 明確性: 曖昧さの排除
- 実用性: 実装に直接活用可能
- 一貫性: プロジェクト全体との整合性
```

### 13. フィードバックループの構築

#### 13.1 レビューサイクル
```
1. AI出力の即座レビュー
2. 品質基準との比較
3. 改善点の特定と優先順位付け
4. 修正指示の具体化
5. 再生成と検証
```

#### 13.2 学習の蓄積
```
改善ポイントの記録:
- 効果的だったプロンプト手法
- 回避すべきアンチパターン
- プロジェクト固有の最適解
- 品質向上のためのチェックリスト
```

---

## 🚀 実践的活用例

### 14. 具体的なプロンプト例

#### 14.1 新機能実装の場合
```
### 機能実装要求
機能: WebAuthn Passkey登録機能
対象システム: Scholar Prover PWA
技術制約: 
- React 18 + TypeScript
- WebAuthn Level 2準拠
- IndexedDB永続化
- エラーハンドリング必須

期待する出力:
- React Hooks実装
- TypeScript型定義
- エラーハンドリング
- ユニットテスト
- 使用例とドキュメント

セキュリティ要件:
- CSP対応
- 入力検証
- 秘密情報の適切な処理
```

#### 14.2 バグ修正の場合
```
### バグ修正要求
問題: [具体的な問題の説明]
再現手順: [ステップバイステップ]
期待する動作: [正しい動作の説明]
現在の動作: [問題のある動作の説明]
影響範囲: [影響を受ける機能]

要求する出力:
- 根本原因の分析
- 修正方法の提案
- 修正後のテスト方法
- 回帰テストの追加
```

### 15. 効率的なデバッグとトラブルシューティング

#### 15.1 問題解決のためのAI活用
```
デバッグプロンプトテンプレート:
1. 問題の具体的な症状
2. エラーメッセージ（ある場合）
3. 発生条件と再現手順
4. 関連するコード部分
5. 試行した解決策
6. 使用している技術スタック

期待する診断:
- 問題の根本原因特定
- 段階的な解決手順
- 予防策の提案
- 関連する潜在的問題の指摘
```

---

## 📊 成功指標と改善サイクル

### 16. AI協働開発の成功指標

#### 16.1 開発効率指標
```
測定項目:
- 初回実装成功率: 目標 80%以上
- レビュー修正回数: 目標 2回以下
- 実装時間短縮率: 目標 50%以上
- バグ発見率: 目標 90%以上
```

#### 16.2 品質指標
```
測定項目:
- コード品質スコア: 目標 A評価以上
- セキュリティ脆弱性: 目標 0件
- パフォーマンス基準達成率: 目標 100%
- ユーザビリティスコア: 目標 4.5/5.0以上
```

### 17. 継続的改善プロセス

#### 17.1 週次レビュー
```
レビュー項目:
- AI活用効果の測定
- 問題点と改善点の特定
- プロンプト手法の最適化
- 新たなベストプラクティスの発見
```

#### 17.2 月次改善
```
改善活動:
- デザインルールの更新
- プロンプトテンプレートの改良
- 品質基準の見直し
- チーム知識の共有
```

---

## 🎯 まとめ：AI協働開発の極意

### 18. 成功のための7つの黄金律

1. **明確性**: 曖昧さを排除し、具体的で実行可能な指示を提供
2. **構造化**: 情報を段階的に整理し、AIの理解を最大化
3. **検証性**: 全ての出力が検証・テスト可能な形で要求
4. **反復性**: 継続的なフィードバックループによる品質向上
5. **専門性**: プロジェクト固有の知識とコンテキストの活用
6. **効率性**: 開発速度とコード品質の両立
7. **革新性**: AI協働による新たな開発手法の探求

### 19. プロジェクト成功への道筋

```
Trust Minimized × AI協働開発 = 革新的なゼロトラスト証明システム

最終目標:
- 開発効率の劇的向上
- 極めて高いコード品質
- 完全なセキュリティ
- 優れたユーザーエクスペリエンス
- プロジェクトの確実な成功
```

---

**このデザインルールは、AIパートナーと共に継続的に進化し、zk-CertFrameworkプロジェクトの成功を支える基盤となります。** 